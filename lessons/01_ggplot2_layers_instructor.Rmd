---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Layers chapter: layers stack, they don't replace. display
Total points: 67

## Introduction

You've already learned the basics of ggplot2: how to create scatterplots and boxplots, how to map aesthetics like color and shape, and how to customize your plots with themes and labels. 

In this chapter, we'll dive deeper into the **grammar of graphics** - the idea that you can build every graph from the same components: a dataset, a coordinate system, and geoms (geometric objects that represent data points). We'll explore:

- A deeper understanding of **aesthetic mappings** (inside vs outside aes)
- More **geometric objects** (geoms) for different plot types
- **Faceting** - creating multiple plots split by categories
- **Statistical transformations** - calculations ggplot2 does behind the scenes
- **Position adjustments** - how geoms are positioned relative to each other

We won't cover every single function and option, but we'll walk you through the most important and commonly used functionality in ggplot2.

### Prerequisites

Load the necessary packages into your session:

```{r}
library(tidyverse)           # for ggplot2 and mpg
library(patchwork)           # for combining plots
library(scales)              # for axis formatting
```


## Aesthetic mappings

The `mpg` data frame is bundled with the ggplot2 package and contains
`r nrow(mpg)` observations on `r mpg |> distinct(model) |> nrow()` car
models from [fueleconomy.gov](https://fueleconomy.gov/). 

```{r include = F}
?mpg
names(mpg)
```

Among the variables in `mpg` are:

1. `displ`: A car's engine size (displacement), in liters. A numerical variable.

2. `hwy`: A car's fuel efficiency on the highway, in miles per gallon
    (mpg). A car with a low fuel efficiency consumes more fuel than a
    car with a high fuel efficiency when they travel the same distance.
    A numerical variable.

3. `class`: Type of car. A categorical variable.

Let's start by visualizing the relationship between `displ` and `hwy`
for various `classes` of cars. We can do this with a scatterplot where
the numerical variables are mapped to the `x` and `y` aesthetics and the
categorical variable is mapped to an aesthetic like `color` or `shape`.

```{r}
# Mapping class to color works well
ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point()
```

Notice how each class gets a different color automatically. Now let's try using shape instead:

```{r}
# Mapping class to shape produces warnings
ggplot(mpg, aes(x = displ, y = hwy, shape = class)) +
  geom_point()
```

When `class` is mapped to `shape`, we get two warnings:

> 1: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; we have 7.
> Consider specifying shapes manually if you must have them.
>
> 2: Removed 62 rows containing missing values (`geom_point()`).

Since `ggplot2` will only use six shapes at a time, by default, additional groups will go unplotted when you use the shape aesthetic.
The second warning is related -- there are 62 SUVs in the dataset and they're not plotted.

We have to remember that ggplot2 does not replace but layers. For example:

```{r}
# Create a saved plot
p1 <- ggplot(mpg, aes(x = displ, y = hwy, color = class)) + 
  geom_point()

p1  # p1

```

```{r}
# Save a plot
p1 <- ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point()

p1  # Show original

# Step 1: Try to make points bigger
p1 + geom_point(size = 4)
# "Looks like it worked!" (because bigger covers smaller)

# Step 2: Now try to make them smaller  
p1 + geom_point(size = 2)
# "Wait... now I see BOTH layers! Small points on top of the original size!"
```


What if I wanted to make all the points bigger? If I add another geom_point(size = 10), it looks like it worked!

```{r}

p1 + geom_point(size = 10)
```

What if I wanted too make all the points smaller?

**The grammar of graphics works like painting - each `+` adds a new layer of paint on top.** You can paint over something, but the old layer is still there underneath. When the new layer is bigger, it hides the original. When it's smaller, you see both!

**Layers stack, they don't replace!**

To actually change `p1`, you need to recreate it from scratch:
```{r}
p1 <- ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point(size = 10)
```

However, you CAN modify **non-data elements** - these are like changing the frame around your painting, not the painting itself:
```{r}
# Change the labels
p1 + labs(title = "Fuel Efficiency by Car Class")

# Change the theme  
p1 + theme_classic()
```

These don't add new data layers - they modify how the existing plot is displayed.

**The rule:**
- **Data layers** (geom_point, geom_line, etc.) → Stack like layers of paint
- **Display elements** (labs, themes) → Modify the frame and presentation


Sometimes it's helpful to compare plots side-by-side. The `patchwork` package makes this easy:

```{r}
# Save plots to variables
p1 <- ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point()

p2 <- ggplot(mpg, aes(x = displ, y = hwy, shape = class)) +
  geom_point()

# Combine side-by-side with +
p1 + p2
```

You can also stack plots vertically using `/`:

```{r}
# Stack plots vertically
p1 / p2
```

This is particularly useful when comparing different visualizations of the same data, as you'll often need to do in your research when comparing treatment groups or experimental conditions.



**What about other aesthetics?** Similarly, we can map `class` to `size` or `alpha` aesthetics as well, which control the size and the transparency of the points, respectively.

```{r}
# class mapped to size
ggplot(mpg, aes(x = displ, y = hwy, size = class)) +
  geom_point() 
```

```{r}
# class mapped to alpha
ggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +
  geom_point() 
```

Both of these produce warnings as well:

> Using size for a discrete variable is not advised.
> Using alpha for a discrete variable is not advised.

Mapping an unordered discrete (categorical) variable (`class`) to an ordered aesthetic (`size` or `alpha`) is generally not a good idea because it implies a ranking that does not in fact exist.

Once you map an aesthetic, `ggplot2` automatically:
- Chooses appropriate values (colors, shapes, sizes)
- Creates a legend showing what each value means
- For x and y aesthetics, creates axis labels instead of legends

You can also set the visual properties of your `geom` manually as an argument of your `geom` function (*outside* of `aes()`) instead of relying on a variable mapping to determine the appearance. For example, we can make all of the points in our plot blue:

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(color = "blue") 
```

What you CAN put in ggplot():
✅ INSIDE aes() - mappings from your data
```{r} 
ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point()
```
# ✅ This works! Color varies by the 'class' variable

What you CANNOT put in ggplot():
❌ OUTSIDE aes() - constants

```{r, eval=FALSE}

ggplot(mpg, aes(x = displ, y = hwy), color = "blue") +
  geom_point()
```
# ❌ This fails! Constants can't go in ggplot()

You can't put anything outside the `aes` except for data in the ggplot argument because The Correct Rule:

In ggplot(aes()):

✅ Mappings from data (variables): aes(color = class)
✅ Any aesthetic that varies by data can go here
✅ Gets inherited by all layers

In ggplot() but OUTSIDE aes():

❌ Constants like color = "blue" DON'T work here
✅ Only data and mapping arguments

In geom_*() OUTSIDE aes():

✅ Constants: geom_point(color = "blue")

Summary:

Variables → inside aes() (can be in ggplot() or geom_*())
Constants → outside aes(), but ONLY in geom_*(), NOT in ggplot()

Here, the **color** doesn't convey information about a variable, but only changes the appearance of the plot.

You'll need to pick a value that makes sense for that aesthetic:

-   The name of a color as a character string, e.g., `color = "blue"`
-   The size of a point in mm, e.g., `size = 1`
-   The shape of a point as a number, e.g, `shape = 1`, as shown in Figure \@ref(fig:fig-shapes)

```{r fig-shapes, echo=FALSE, fig.asp=0.364, fig.align='center', fig.cap='Mapping between shapes and their numeric codes.'}
shapes <- tibble(
  shape = c(0, 1, 2, 5, 3, 4, 6:19, 20, 21, 22, 23, 24),
  x = (0:24 %/% 5) / 2,
  y = (-(0:24 %% 5)) / 4
)

ggplot(shapes, aes(x, y)) + 
  geom_point(aes(shape = shape), size = 5, fill = "red") +
  geom_text(aes(label = shape), hjust = 0, nudge_x = 0.15) +
  scale_shape_identity() +
  expand_limits(x = 4.1) +
  scale_x_continuous(NULL, breaks = NULL) + 
  scale_y_continuous(NULL, breaks = NULL, limits = c(-1.2, 0.2)) + 
  theme_minimal() +
  theme(aspect.ratio = 1/2.75)
```

So far we have discussed aesthetics that we can map or set in a scatterplot, when using a point `geom`. You can learn more about all possible aesthetic mappings in the aesthetic specifications vignette at <https://ggplot2.tidyverse.org/articles/ggplot2-specs.html>.

The specific aesthetics you can use for a plot depend on the `geom` you use to represent the data.

::: {.infobox .tip}
### Where do aesthetics go in ggplot2?

**The key question:** Is this value from your data, or is it a constant?

**From your data** (a column name) → INSIDE `aes()`
```{r}
# color varies by class (class is a column in mpg)
ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point()
```

**A constant** (same for all points) → OUTSIDE `aes()`
```{r}
# all points are pink
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(color = "pink", size = 3)
```

**Memory trick:** Can you do `mpg$class`? YES → inside `aes()`  
Can you do `mpg$pink`? NO → outside `aes()`
:::

The Universal Rule for ALL aesthetics:
WhereVariable (from data)Constant (fixed value)ggplot(aes(...))✅ aes(size = cyl)❌ Can't do thisgeom_*(aes(...))✅ aes(size = cyl)❌ Can't do thisgeom_*(...) outside aes❌ Can't do this✅ size = 3
So size, color, shape, alpha, fill - all follow the same pattern.

In the next section we dive deeper into `geoms`.

### 2.2.1 Exercises {.unnumbered}

1. Create a scatterplot of `hwy` vs. `displ` where the points are pink filled in triangles. +2pts

::: {.fold .s .o}
```{r Ans-2.2.1.1}
ggplot(mpg, aes(x = hwy, y = displ)) +
  geom_point(color = "pink", shape = 24, size = 3, fill = "pink")
```
:::

2. What does the `stroke` aesthetic do? What shapes does it work with? (Hint: use `?geom_point`). Add stroke to the above plot. +2pts

::: {.fold .s .o}
**Ans-2.2.1.2:**
```{r Ans-2.2.1.2}
# Stroke controls the width of the edge/border for the shapes (21-25)
# that have a fill aesthetic.
ggplot(mpg, aes(x = hwy, y = displ)) +
  geom_point(color = "black", shape = 24, size = 3, fill = "pink", stroke = 5)
```
:::

3. Why did the following code not result in a plot with blue points? +2pts
```{r, eval = FALSE}
ggplot(mpg) + 
  geom_point(aes(x = displ, y = hwy, color = "blue"))
```

::: {.fold .s .o}
**Ans-2.2.1.3:**

The points are NOT blue because `color = "blue"` is inside `aes()`.

When you put a value inside `aes()`, ggplot2 thinks it's a column name from your data. Since there's no column called "blue", ggplot2 creates a fake categorical variable with one value (the string "blue") and assigns it the first default color (salmon/coral).

**The fix - move color OUTSIDE aes():**
```{r}
# Correct: color is a constant, so it goes outside aes()
ggplot(mpg) + 
  geom_point(aes(x = displ, y = hwy), color = "blue")
```

**The rule:**
- **Inside `aes()`**: for column names from your data
  - Example: `aes(color = class)` - `class` is a column
- **Outside `aes()`**: for fixed constants
  - Example: `color = "blue"` - "blue" is a constant

**Memory trick:** Can you do `mpg$blue`? NO! → Then it goes OUTSIDE `aes()`
:::

4. What's wrong with the following code? How would you fix it? +2pts
```{r, eval = FALSE}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(color = class, size = 3)
```

::: {.fold .s .o}
**Ans-2.2.1.4:**

This code will give an error: `Error: object 'class' not found`

`class` is a column name from the data, so it must go **inside** `aes()`. When you put it outside, R looks for an object called `class` in your environment (not in the data) and doesn't find it.

**The fix:**
```{r}
# Correct: class is from data, so it goes inside aes()
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class), size = 3)
```

Note that `size = 3` stays outside `aes()` because it's a constant (all points are size 3).

**The key difference:**
- **Inside `aes()`**: R looks for columns in your data
- **Outside `aes()`**: R looks for objects in your environment
:::

5. What happens if you map an aesthetic to something other than a variable name, like `aes(color = displ < 5)`? Try it by adding color to the following plot: +2pts
```{r, eval = FALSE}
ggplot(mpg) + geom_point(aes(x = displ, y = hwy))
```

::: {.fold .s .o}
**Ans-2.2.1.5:**
```{r}
# It creates a logical variable with values `TRUE` and `FALSE` 
# for cars with displacement values below and above 5. 

# Notice color is inside aes() because we're creating a variable
# from the data (the result of displ < 5).

ggplot(mpg) + 
  geom_point(aes(x = displ, y = hwy, color = displ < 5)) 
```
:::

6. What's wrong with the following code? Why doesn't it make blue points? How would you fix it? +2pts
```{r, eval = FALSE}
ggplot(mpg, aes(x = displ, y = hwy), color = "blue") + 
  geom_point()
```

::: {.fold .s .o}
**Ans-2.2.1.6:**

This code produces a warning: 
```
Warning message:
In fortify(data, ...) : Arguments in `...` must be used.
x Problematic argument:
* color = "blue"
```

The problem is that `color = "blue"` is in the **wrong place**. The `ggplot()` function only accepts `data` and `mapping = aes()` arguments. You cannot put styling constants (like `color`, `size`, `alpha`) directly in `ggplot()`.

Constants must go in the `geom_*()` layer, outside `aes()`:
```{r}
# Correct: constant in geom layer
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(color = "blue")
```

**Where things can go:**
- **In `ggplot()`**: Only `data` and `aes()` mappings
- **In `geom_*()` outside `aes()`**: Constants like `color = "blue"`, `size = 3`
- **In `aes()` (anywhere)**: Variables from your data like `color = class`
:::

## Geometric objects

You've already learned about `geom_point()` and `geom_boxplot()` in your previous lessons. A `geom` is the geometrical object that a plot uses to represent data. People often describe plots by the type of geom that the plot uses. For example, bar charts use bar geoms (`geom_bar()`), line charts use line geoms (`geom_line()`), boxplots use boxplot geoms (`geom_boxplot()`), and scatterplots use point geoms (`geom_point()`).

How are these two plots similar?

```{r}
# Scatterplot
ggplot(mpg, aes(x = displ, y = hwy)) +  
  geom_point() 
```

```{r}
# Smooth line
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_smooth()
```

Both plots contain the same x variable, the same y variable, and both describe the same data. But the plots are not identical. Each plot uses a different geometric object, `geom`, to represent the data. The first plot uses the point `geom`, and the second uses the smooth `geom`, a smooth line fitted to the data.

To change the `geom` in your plot, change the `geom` function that you add to `ggplot()`.

Every `geom` function in ggplot2 takes a `mapping` argument, either defined locally in the `geom` layer or globally in the `ggplot()` layer.

However, not every aesthetic works with every `geom`. You could set the shape of a point, but you couldn't set the "shape" of a line. If you try, ggplot2 will silently ignore that aesthetic mapping. On the other hand, you *could* set the `linetype` of a line.

`geom_smooth()` will draw a different line, with a different `linetype`, for each unique value of the variable that you map to `linetype`.

```{r}
# Shape doesn't work with geom_smooth - no legend appears
ggplot(mpg, aes(x = displ, y = hwy, shape = drv)) + 
  geom_smooth()
```

```{r}
# Linetype DOES work with geom_smooth
ggplot(mpg, aes(x = displ, y = hwy, linetype = drv)) + 
  geom_smooth()
```

Here, `geom_smooth()` separates the cars into three lines based on their `drv` value, which describes a car's drive train. Here, `4` stands for four-wheel drive, `f` for front-wheel drive, and `r` for rear-wheel drive.

**Notice there is no legend for the first plot because geom_smooth does not have a shape aesthetic.**

If this sounds strange, we can make it clearer by overlaying the lines on top of the raw data and then coloring everything according to `drv`.

```{r}
ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point() + 
  geom_smooth(aes(linetype = drv))
```

Notice that this plot contains **two geoms in the same graph**. This is a powerful feature of ggplot2 - you can layer multiple geoms to show different aspects of your data.

You can use the same idea to specify different `data` for each layer.
Here, we use red points to highlight two-seater cars.
The local data argument in `geom_point()` overrides the global data argument in `ggplot()` for that layer only.

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  geom_point(
   data  = mpg |> filter(class == '2seater'),
    color = "red",
    size = 3
  )
```

`geoms` are the fundamental building blocks of `ggplot2`. You can completely transform the look of your plot by changing its geom, and different `geoms` can reveal different features of your data. 

For example, these three plots show the same data (highway mileage) but reveal different patterns:

```{r}
# Histogram shows distribution
ggplot(mpg, aes(x = hwy)) + 
  geom_histogram(binwidth = 2)
```

```{r}
# Density plot shows smooth distribution
ggplot(mpg, aes(x = hwy)) + 
  geom_density()
```

```{r}
# Boxplot shows summary statistics and outliers
ggplot(mpg, aes(x = hwy)) + 
  geom_boxplot()
```

The histogram and density plot reveal that the distribution of highway mileage is bimodal and right skewed, while the boxplot reveals two potential outliers.

`ggplot2` provides more than 40 `geoms` but these don't cover all possible plots one could make. The best place to get a comprehensive overview of all of the `geoms` `ggplot2` offers is the reference page: <https://ggplot2.tidyverse.org/reference>.
To learn more about any single `geom`, use the help (e.g., `?geom_smooth`).

### 2.3.1 Exercises {.unnumbered}

1. What `geom` would you use to draw a line chart? A boxplot? A histogram? An area chart? +2pts

::: {.fold .s .o}
**Ans-2.3.1.1:**

For a line chart you can use `geom_path()` or `geom_line()`. 
                    
For a boxplot you can use `geom_boxplot()`.

For a histogram, `geom_histogram()`.

For an area chart, `geom_area()`.
:::

2. Earlier in this chapter we used `show.legend` without explaining it. What does `show.legend = FALSE` do in the code below? What happens if you remove it? +2pts

```{r
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth(aes(color = drv), show.legend = FALSE)
```

::: {.fold .s .o}
**Ans-2.3.1.2:**

It removes the legend for the `geom` it's specified in. In this case it removes the legend for the smooth lines that are colored based on `drv`.

If you remove `show.legend`, it will show the legend as the default is `show.legend = TRUE`.

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth(aes(color = drv))
```
:::

3. What does the `se` argument to `geom_smooth()` do? +2pts

::: {.fold .s .o}
**Ans-2.3.1.3:**

It displays the confidence interval (standard error) around the smooth line.
You can remove this with `se = FALSE`.

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth(se = FALSE)
```
:::

4. Will these two graphs look different? Why/why not? +2pts

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  geom_smooth()

ggplot() +
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
```

::: {.fold .s .o}
**Ans-2.3.1.4:**

No, they will look the same. In the first plot, the data and aesthetic mappings are defined globally in `ggplot()` and inherited by both geoms. In the second plot, each geom has its own local data and mappings that are identical. The result is the same plot.
:::

## Facets

Facets are a powerful way to split your plot into multiple subplots based on the values of one or more categorical variables. This is especially useful when you want to see patterns within different groups.

You've already seen this concept - it's similar to creating separate boxplots for each genotype in your previous exercise!

To facet your plot by a single variable, use `facet_wrap()`. The first argument of `facet_wrap()` is a formula (created with `~` followed by a variable name). The variable passed to `facet_wrap()` should be categorical.

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  facet_wrap(~ class, nrow = 2)
```

To facet your plot with the combination of two variables, switch from
`facet_wrap()` to `facet_grid()`. The first argument of `facet_grid()`
is also a formula, but now it's a double sided formula: `rows ~ cols`.

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  facet_grid(drv ~ cyl)
```

The first variable in `facet_grid()` determines the faceting by row, the second by column.

By default each of the facets share the same scale and range for x and y axes. This is useful when you want to compare data across facets, but it can be limiting when you want to visualize the relationship within each facet better.

Setting the `scales` argument in a faceting function to `"free"` will allow for different axis scales across both rows and columns, `"free_x"` will allow for different scales across columns, and `"free_y"` will allow for different scales across rows.

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  facet_grid(drv ~ cyl, scales = "free_y")
```

### 2.4.1 Exercises {.unnumbered}

1. What happens if you facet on a continuous variable? Try faceting the plot below on `hwy`. +2pts

```{r}
ggplot(mpg, aes(x = drv, y = cyl)) + 
  geom_point()
```

::: {.fold .s .o}
**Ans-2.4.1.1:**

Faceting by a continuous variable results in one facet for each unique value of the continuous variable. We can see this in the scatterplot below of `cyl` vs. `drv`, faceted by `hwy`.

```{r}
ggplot(mpg, aes(x = drv, y = cyl)) + 
  geom_point() +
  facet_wrap(~ hwy)
```

This creates many facets (one for each unique highway mpg value), which usually isn't useful!
:::

2. Run the following code and facet on `drv` vs `cyl` using `facet_grid()`. What do the empty cells mean? +2pts

```{r}
ggplot(mpg, aes(x = drv, y = cyl)) + 
  geom_point()
```

::: {.fold .s .o}
**Ans-2.4.1.2:**

There are no cars with certain combinations of drive train and cylinders. For example, there are no cars with rear-wheel drive and 5 cylinders. Therefore the facet corresponding to that combination is empty. In general, empty facets mean no observations fall in that category.

```{r}
ggplot(mpg, aes(x = drv, y = cyl)) + 
  geom_point() +
  facet_grid(drv ~ cyl)
```
:::

3. What plots does the following code make? What does `.` do? +2pts

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  facet_grid(drv ~ .)

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  facet_grid(. ~ cyl)
```

::: {.fold .s .o}
**Ans-2.4.1.3:**

In the first plot, with `facet_grid(drv ~ .)`, the period means "don't facet across columns" - so you get facets in rows only.

In the second plot, with `facet_grid(. ~ cyl)`, the period means "don't facet across rows" - so you get facets in columns only.

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  facet_grid(drv ~ .)

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  facet_grid(. ~ cyl)
```
:::

4. Take the first faceted plot in this section:

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  facet_wrap(~ class, nrow = 2)
```

What are the advantages to using faceting instead of the color aesthetic? What are the disadvantages? +2pts

::: {.fold .s .o}
**Ans-2.4.1.4:**

**Advantages of faceting:**
- Each class is shown separately, with no overplotting
- Patterns within each class are easier to see
- Works well with many categories (color gets hard to distinguish with 7+ categories)

**Disadvantages of faceting:**
- Harder to compare classes directly to each other when they're in separate plots
- Takes up more space on the page
- Can be harder to see the overall pattern across all data

**Comparison:**
```{r}
# Faceting - easier to see within-class patterns
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  facet_wrap(~ class, nrow = 2)

# Color - easier to compare across classes
ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point()
```

You can also combine both approaches!
:::

5. Read `?facet_wrap`. What does `nrow` do? What does `ncol` do? Why doesn't `facet_grid()` have `nrow` and `ncol` arguments? +2pts

::: {.fold .s .o}
**Ans-2.4.1.5:**

`nrow` sets the number of rows in the facet layout.
`ncol` sets the number of columns in the facet layout.

`facet_grid()` doesn't have `nrow` and `ncol` arguments because the number of rows and columns is determined by the number of unique values of the variables you're faceting by. For example, if you facet by `drv ~ cyl`, the number of rows is determined by the number of unique `drv` values (3), and the number of columns by the number of unique `cyl` values (4).
:::

## Statistical transformations

Consider a basic bar chart, drawn with `geom_bar()`. The following chart displays the total number of diamonds in the `diamonds` dataset, grouped by `cut`. The `diamonds` dataset is in the `ggplot2` package and contains information on ~54,000 diamonds, including the `price`, `carat`, `color`, `clarity`, and `cut` of each diamond. The chart shows that more diamonds are available with high quality cuts than with low quality cuts.

```{r}
ggplot(diamonds, aes(x = cut)) + 
  geom_bar()
```

On the x-axis, the chart displays `cut`, a variable from `diamonds`. On the y-axis, it displays count, but count is not a variable in `diamonds`! Where does count come from? 

Many graphs, like scatterplots, plot the raw values of your dataset. Other graphs, like bar charts, calculate new values to plot:

-   Bar charts, histograms, and frequency polygons bin your data and then plot bin counts, the number of points that fall in each bin.

-   Smoothers fit a model to your data and then plot predictions from the model.

-   Boxplots compute the five-number summary of the distribution and then display that summary as a specially formatted box.

The algorithm used to calculate new values for a graph is called a **stat**, short for statistical transformation.

You can learn which stat a `geom` uses by inspecting the default value for the `stat` argument. For example, `?geom_bar` shows that the default value for `stat` is "count", which means that `geom_bar()` uses `stat_count()`. `stat_count()` is documented on the same page as `geom_bar()`. If you scroll down, the section called "Computed variables" explains that it computes two new variables: `count` and `prop`.

Every `geom` has a default stat; and every stat has a default `geom`. This means that you can typically use `geoms` without worrying about the underlying statistical transformation. However, there are three reasons why you might need to use a stat explicitly:

1. **You might want to override the default stat.** In the code below, we change the stat of `geom_bar()` from count (the default) to identity. This lets us map the height of the bars to the raw values of a y variable.

```{r}
diamonds |>
  count(cut) |>
  ggplot(aes(x = cut, y = n)) +
  geom_bar(stat = "identity")
```

2. **You might want to override the default mapping from transformed variables to aesthetics.** For example, you might want to display a bar chart of proportions, rather than counts:

```{r}
ggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) +
  geom_bar()
```

The `prop` variable is a computed value provided by the `stat = "count"` transformation (the default for `geom_bar`). To find the possible variables that can be computed by the stat, look for the section titled "computed variables" in the help for `geom_bar()`.

`ggplot2` provides more than 20 stats for you to use. Each stat is a function, so you can get help in the usual way, e.g., `?stat_bin`.

### 2.5.1 Exercises {.unnumbered}

1. What does `geom_col()` do? How is it different from `geom_bar()`? +2pts

::: {.fold .s .o}
**Ans-2.5.1.1:**

`geom_bar()` uses `stat_count()` by default: it counts the number of occurrences for each x value or category. It doesn't expect a y-value, since it's going to count that up itself.

`geom_col()` is the same as `geom_bar(stat = 'identity')`. Use `geom_col()` when your data already contains both x values and y values (counts).

**Example:**
```{r}
# geom_bar counts for you
ggplot(mpg, aes(x = class)) + 
  geom_bar()

# geom_col requires pre-counted data
mpg |>
  count(class) |>
  ggplot(aes(x = class, y = n)) +
  geom_col()
```
:::

2. Most geoms and stats come in pairs that are almost always used in concert. Make a list of all the pairs. What do they have in common? (Hint: Read through the documentation.) +2pts

::: {.fold .s .o}
**Ans-2.5.1.2:**

Common geom/stat pairs:
- `geom_bar()` / `stat_count()`
- `geom_bin2d()` / `stat_bin_2d()`
- `geom_boxplot()` / `stat_boxplot()`
- `geom_contour()` / `stat_contour()`
- `geom_count()` / `stat_sum()`
- `geom_density()` / `stat_density()`
- `geom_histogram()` / `stat_bin()`
- `geom_smooth()` / `stat_smooth()`

They have in common that the `geom` function and `stat` function have the same suffix (e.g., `_count`, `_bin`, `_boxplot`). Each geom has a default stat, and each stat has a default geom.
:::

3. What variables does `stat_smooth()` compute? What arguments control its behavior? +2pts

::: {.fold .s .o}
**Ans-2.5.1.3:**

`stat_smooth()` computes:
- `y` or `x`: predicted value
- `ymin` or `xmin`: lower pointwise confidence interval
- `ymax` or `xmax`: upper pointwise confidence interval
- `se`: standard error

Key arguments that control its behavior:
- `method`: smoothing method (e.g., "lm", "loess", "gam")
- `se`: whether to display confidence interval (TRUE/FALSE)
- `level`: level of confidence interval (default 0.95)
- `span`: controls amount of smoothing for loess

You can see all of these in `?stat_smooth` or `?geom_smooth`.
:::

## Position adjustments

There's one more piece of magic associated with bar charts. You can color a bar chart using either the `color` aesthetic, or, more usefully, the `fill` aesthetic:

```{r}
# Color only affects the outline
ggplot(mpg, aes(x = drv, color = drv)) + 
  geom_bar()
```

```{r}
# Fill colors the inside of the bars
ggplot(mpg, aes(x = drv, fill = drv)) + 
  geom_bar()
```

Note what happens if you map the fill aesthetic to another variable, like `class`: the bars are automatically stacked. Each colored rectangle represents a combination of `drv` and `class`.

```{r}
ggplot(mpg, aes(x = drv, fill = class)) + 
  geom_bar()
```

The stacking is performed automatically using the **position adjustment** specified by the `position` argument. If you don't want a stacked bar chart, you can use one of three other options: `"identity"`, `"dodge"` or `"fill"`.

-   `position = "fill"` works like stacking, but makes each set of stacked bars the same height. This makes it easier to compare proportions across groups.

-   `position = "dodge"` places overlapping objects directly *beside* one another. This makes it easier to compare individual values.

```{r}
# Fill makes all bars the same height (shows proportions)
ggplot(mpg, aes(x = drv, fill = class)) +
  geom_bar(position = "fill")
```

```{r}
# Dodge places bars side-by-side
ggplot(mpg, aes(x = drv, fill = class)) +
  geom_bar(position = "dodge")
```

There's one other type of adjustment that's not useful for bar charts, but can be very useful for scatterplots. Recall our first scatterplot. Did you notice that the plot displays only 126 points, even though there are 234 observations in the dataset?

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point()
```

The underlying values of `hwy` and `displ` are rounded so the points appear on a grid and many points overlap each other. This problem is known as **overplotting**. This arrangement makes it difficult to see the distribution of the data.

You can avoid this gridding by setting the position adjustment to "jitter". `position = "jitter"` adds a small amount of random noise to each point. This spreads the points out because no two points are likely to receive the same amount of random noise.

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(position = "jitter")
```

Adding randomness seems like a strange way to improve your plot, but while it makes your graph less accurate at small scales, it makes your graph *more* revealing at large scales. Because this is such a useful operation, `ggplot2` comes with a shorthand for `geom_point(position = "jitter")`: `geom_jitter()`.

To learn more about a position adjustment, look up the help page associated with each adjustment: `?position_dodge`, `?position_fill`, `?position_identity`, `?position_jitter`, and `?position_stack`.

### 2.6.1 Exercises {.unnumbered}

1. What is the problem with the following plot? How could you improve it? +2pts

```{r}
ggplot(mpg, aes(x = cty, y = hwy)) +
  geom_point()
```

::: {.fold .s .o}
**Ans-2.6.1.1:**

The `mpg` dataset has 234 observations, however the plot shows fewer observations than that. This is due to overplotting; many cars have the same city and highway mileage. This can be addressed by jittering the points.

```{r}
# Solution 1: Add jitter
ggplot(mpg, aes(x = cty, y = hwy)) +
  geom_jitter()

# Solution 2: Use position = "jitter"
ggplot(mpg, aes(x = cty, y = hwy)) +
  geom_point(position = "jitter")
```
:::

2. What, if anything, is the difference between these two plots? Why? +2pts

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() 

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(position = "identity") 
```

::: {.fold .s .o}
**Ans-2.6.1.2:**

They are identical because `position = "identity"` is the default value for `geom_point`.
:::

3. What parameters to `geom_jitter()` control the amount of jittering? Add jittering to the following plot: +2pts

```{r}
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() 
```

::: {.fold .s .o}
**Ans-2.6.1.3:**

The `width` and `height` parameters control the amount of horizontal and vertical displacement, respectively. Higher values mean more displacement.

```{r}
# Default jitter
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_jitter()

# Custom jitter amount
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_jitter(width = 0.5, height = 0.5)
```
:::

4. Compare and contrast `geom_jitter()` with `geom_count()` using the following ggplot. +2pts

```{r}
g <- ggplot(mpg, aes(x = displ, y = hwy))
```

::: {.fold .s .o}
**Ans-2.6.1.4:**

`geom_jitter()` adds random noise to the location of the points to avoid overplotting by spreading them out.

`geom_count()` sizes the points based on the number of observations at a given location - larger points indicate more overlapping observations.

```{r}
# Jitter spreads points out
g + geom_jitter()
```

```{r}
# Count sizes points by number of observations
g + geom_count()
```

Use jitter when you want to see individual data points. Use count when you want to see how many observations are at each location.
:::

5. What's the default position adjustment for `geom_boxplot()`? Create a visualization of the `mpg` dataset that demonstrates it. +2pts

::: {.fold .s .o}
**Ans-2.6.1.5:**

The default position for `geom_boxplot()` is `"dodge2"`.

```{r}
# Default position (dodge2)
ggplot(mpg, aes(x = class, y = hwy, fill = drv)) +
  geom_boxplot()

# Explicitly setting position to dodge2 (same result)
ggplot(mpg, aes(x = class, y = hwy, fill = drv)) +
  geom_boxplot(position = "dodge2")
```

The dodge2 position places boxplots side-by-side within each class, making it easy to compare different groups.
:::

## Summary

In this chapter you learned about the layered grammar of graphics starting with aesthetics and geometries to build a simple plot, facets for splitting the plot into subsets, statistics for understanding how `geoms` are calculated, position adjustments for controlling the fine details of position when `geoms` might otherwise overlap.

### Key concepts learned:

1. **Aesthetics**: Map variables from your data to visual properties
   - Inside `aes()` for variables: `aes(color = class)`
   - Outside `aes()` for constants: `color = "blue"`

2. **Geoms**: The geometric objects that represent your data
   - `geom_point()`, `geom_line()`, `geom_bar()`, `geom_boxplot()`, etc.
   - Can layer multiple geoms in one plot

3. **Facets**: Split your plot into subplots
   - `facet_wrap()` for one variable
   - `facet_grid()` for two variables

4. **Stats**: Statistical transformations that create new variables
   - Bar charts count observations
   - Boxplots compute summary statistics
   - Smoothers fit models

5. **Position adjustments**: Fine-tune positioning
   - `position = "dodge"` for side-by-side bars
   - `position = "fill"` for proportional stacking
   - `position = "jitter"` for avoiding overplotting

Two very useful resources for getting an overview of the complete `ggplot2` functionality are the `ggplot2` cheatsheet (which you can find at <https://posit.co/resources/cheatsheets>) and the `ggplot2` package documentation at <https://ggplot2.tidyverse.org/reference>.

