[["index.html", "PHAR 520: Applied Omics Science for Drug Discovery and Development ModuleIII: 2025_r4ds-ggplot2 R for data science workshop (r4ds):", " PHAR 520: Applied Omics Science for Drug Discovery and Development ModuleIII: 2025_r4ds-ggplot2 R for data science workshop (r4ds): This module is based on the Data visualization chapter in Hadley Wickham’s book 2nd edition of ‘R 4 data science’(see README.md). "],["layers-stack.html", "Chapter 1 Layers: STACK 1.1 Introduction 1.2 Aesthetic mappings 1.3 Geometric objects 1.4 Facets 1.5 Position adjustments 1.6 Summary", " Chapter 1 Layers: STACK Total points: 43 1.1 Introduction You’ve already learned the basics of ggplot2: how to create scatterplots and boxplots, how to map aesthetics like color and shape, and how to customize your plots with themes and labels. In this chapter, we’ll dive deeper into the grammar of graphics - the idea that you can build every graph from the same components: a dataset, a coordinate system, and geoms (geometric objects that represent data points). We’ll explore: A deeper understanding of aesthetic mappings (inside vs outside aes) More geometric objects (geoms) for different plot types Faceting - creating multiple plots split by categories Position adjustments - how geoms are positioned relative to each other We won’t cover every single function and option, but we’ll walk you through the most important and commonly used functionality in ggplot2. 1.1.1 Prerequisites Load the necessary packages into your session: library(tidyverse) # for ggplot2 and mpg library(patchwork) # for combining plots library(scales) # for axis formatting 1.2 Aesthetic mappings The mpg data frame is bundled with the ggplot2 package and contains 234 observations on 38 car models from fueleconomy.gov. Let’s start by visualizing the relationship between displ and hwy for various classes of cars. We can do this with a scatterplot where the numerical variables are mapped to the x and y aesthetics and the categorical variable is mapped to an aesthetic like color or shape. # Mapping class to color works well ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point() Notice how each class gets a different color automatically. Now let’s try using shape instead: # Mapping class to shape produces warnings ggplot(mpg, aes(x = displ, y = hwy, shape = class)) + geom_point() When class is mapped to shape, we get two warnings: 1: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; we have 7. Consider specifying shapes manually if you must have them. 2: Removed 62 rows containing missing values (geom_point()). Since ggplot2 will only use six shapes at a time, by default, additional groups will go unplotted when you use the shape aesthetic. The second warning is related – there are 62 SUVs in the dataset and they’re not plotted. We have to remember that ggplot2 does not replace, but layers. For example: # Create a saved plot p1 &lt;- ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point(size = 2) p1 # p1 1.2.1 Step1: make the points bigger What if I wanted to make all the points bigger? If I add another geom_point(size = 6), it looks like it worked! p2 = p1 + geom_point(size = 6) p2 1.2.2 Step 2: Now try to make them smaller What if I wanted to make all the points smaller? p3 = p2+ geom_point(size = 2, color = &quot;black&quot;) # &quot;Wait... now I see BOTH layers! Small points on top of the original size!&quot; p3 The grammar of graphics works like painting; each + adds a new layer of paint on top. You can paint over something, but the old layer is still there underneath. When the new layer is bigger, it hides the original. When it’s smaller, you see both! Layers stack, they don’t replace! To actually change p1, you need to recreate it from scratch: p1 &lt;- ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point(size = 6) p1 However, you CAN modify non-data elements - these are like changing the frame around your painting, not the painting itself: # Change the labels p1 + labs(title = &quot;Fuel Efficiency by Car Class&quot;) # Change the theme p1 + theme_classic() These don’t add new data layers - they modify how the existing plot is displayed. The rule: Data layers (geom_point, geom_line, etc.) → Stack like layers of paint Display elements (labs, themes) → Modify the frame and presentation Sometimes it’s helpful to compare plots side-by-side. The patchwork package makes this easy: # Save plots to variables p1 &lt;- ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point() p2 &lt;- ggplot(mpg, aes(x = displ, y = hwy, shape = class)) + geom_point() # Combine side-by-side with + p1 + p2 You can also stack plots vertically using /: # Stack plots vertically p1 / p2 This is particularly useful when comparing different visualizations of the same data, as you’ll often need to do in your research when comparing treatment groups or experimental conditions. What about other aesthetics? Similarly, we can map class to size or alpha aesthetics as well, which control the size and the transparency of the points, respectively. # class mapped to size ggplot(mpg, aes(x = displ, y = hwy, size = class)) + geom_point() # class mapped to alpha ggplot(mpg, aes(x = displ, y = hwy, alpha = class)) + geom_point() Both of these produce warnings as well: Using size for a discrete variable is not advised. Using alpha for a discrete variable is not advised. Mapping an unordered discrete (categorical) variable (class) to an ordered aesthetic (size or alpha) is generally not a good idea because it implies a ranking that does not in fact exist. 1.2.3 Setting Visual Properties Once you map an aesthetic, ggplot2 automatically: Chooses appropriate values (colors, shapes, sizes) Creates a legend showing what each value means For x and y aesthetics, creates axis labels instead of legends You can also set the visual properties of your geom manually as an argument of your geom function (outside of aes()) instead of relying on a variable mapping to determine the appearance. For example, we can make all of the points in our plot blue: ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(color = &quot;blue&quot;) 1.2.4 Where do aesthetics go in ggplot2? The key question: Is this value from your data, or is it a constant? From your data (a column name) → INSIDE aes() # color varies by class (class is a column in mpg) ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point() A constant (same for all points) → OUTSIDE aes(), in the geom layer # all points are pink ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(color = &quot;pink&quot;, size = 3) Memory trick: Can you do mpg$class in R? YES → inside aes() Can you do mpg$pink? NO → outside aes() Important: Constants must go in geom_*(), NOT in ggplot(): # ❌ This fails! ggplot(mpg, aes(x = displ, y = hwy), color = &quot;blue&quot;) + geom_point() # ✅ This works! ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(color = &quot;blue&quot;) 1.2.5 The Universal Rule for ALL Aesthetics Where can variables and constants go? Location Variable (from data)Example: color = class Constant (fixed value)Example: color = \"blue\" ggplot(aes(...)) ✅ YESaes(color = class) ❌ NO geom_*(aes(...)) ✅ YESaes(color = class) ❌ NO geom_*(...) outside aes ❌ NO ✅ YEScolor = \"blue\" 1.2.6 Setting Constant Values You’ll need to pick appropriate values for each aesthetic: The name of a color as a character string, e.g., color = \"blue\" The size of a point in mm, e.g., size = 1 The shape of a point as a number, e.g, shape = 1, as shown in Figure 1.1 Figure 1.1: Mapping between shapes and their numeric codes. So far we have discussed aesthetics that we can map or set in a scatterplot, when using a point geom. You can learn more about all possible aesthetic mappings in the aesthetic specifications vignette at https://ggplot2.tidyverse.org/articles/ggplot2-specs.html. The specific aesthetics you can use for a plot depend on the geom you use to represent the data. In the next section we dive deeper into geoms. 1.2.1 Exercises Create a scatterplot of hwy vs. displ where the points are pink filled in triangles. +2pts What does the stroke aesthetic do? What shapes does it work with? (Hint: use ?geom_point). Add stroke to the above plot. +2pts Ans-1.2.1.3: The points are NOT blue because color = \"blue\" is inside aes(). When you put a value inside aes(), ggplot2 thinks it’s a column name from your data. Since there’s no column called “blue”, ggplot2 creates a fake categorical variable with one value (the string “blue”) and assigns it the first default color (salmon/coral). What’s wrong with the following code? How would you fix it? +2pts ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(color = class, size = 3) What happens if you map an aesthetic to something other than a variable name, like aes(color = displ &lt; 5)? Try it by adding color to the following plot: +2pts ggplot(mpg) + geom_point(aes(x = displ, y = hwy)) What’s wrong with the following code? Why doesn’t it make blue points? How would you fix it? +2pts ggplot(mpg, aes(x = displ, y = hwy), color = &quot;blue&quot;) + geom_point() 1.3 Geometric objects You’ve already learned about geom_point() and geom_boxplot() in your previous lessons. A geom is the geometrical object that a plot uses to represent data. People often describe plots by the type of geom that the plot uses. For example, bar charts use bar geoms (geom_bar()) line charts use line geoms (geom_line()) histograms use histograms geoms (geom_histogram()) density plots use density geoms (geom_density()). How are these two plots similar? # Scatterplot ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() # Smooth line ggplot(mpg, aes(x = displ, y = hwy)) + geom_smooth() Both plots contain the same x variable, the same y variable, and both describe the same data. But the plots are not identical. Each plot uses a different geometric object, geom, to represent the data. The first plot uses the point geom, and the second uses the smooth geom, a smooth line fitted to the data. To change the geom in your plot, change the geom function that you add to ggplot(). Every geom function in ggplot2 takes a mapping argument, either defined locally in the geom layer or globally in the ggplot() layer. However, not every aesthetic works with every geom. You could set the shape of a point, but you couldn’t set the “shape” of a line. If you try, ggplot2 will silently ignore that aesthetic mapping. On the other hand, you could set the linetype of a line. geom_smooth() will draw a different line, with a different linetype, for each unique value of the variable that you map to linetype. # Shape doesn&#39;t work with geom_smooth - no legend appears ggplot(mpg, aes(x = displ, y = hwy, shape = drv)) + geom_smooth() # Linetype DOES work with geom_smooth ggplot(mpg, aes(x = displ, y = hwy, linetype = drv)) + geom_smooth() Here, geom_smooth() separates the cars into three lines based on their drv value, which describes a car’s drive train. Here, 4 stands for four-wheel drive, f for front-wheel drive, and r for rear-wheel drive. As long as the aesthetic in the ggplot argument is compatible with the geoms used you are ok. Notice there is no legend for the first plot because geom_smooth does not have a shape aesthetic. We can make this clearer by overlaying the lines on top of the raw data and then coloring everything according to drv. ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + geom_smooth(aes(linetype = drv)) Notice that this plot contains two geoms in the same graph. This is a powerful feature of ggplot2 - you can layer multiple geoms to show different aspects of your data. You can use the same idea to specify different data for each layer. Here, we use red points to highlight two-seater cars. The local data argument in geom_point() overrides the global data argument in ggplot() for that layer only. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + geom_point( data = mpg |&gt; filter(class == &#39;2seater&#39;), color = &quot;red&quot;, size = 3 ) geoms are the fundamental building blocks of ggplot2. You can completely transform the look of your plot by changing its geom, and different geoms can reveal different features of your data. For example, these three plots show the same data (highway mileage) but reveal different patterns: # Histogram shows distribution ggplot(mpg, aes(x = hwy)) + geom_histogram(binwidth = 2) # Density plot shows smooth distribution ggplot(mpg, aes(x = hwy)) + geom_density() # Boxplot shows summary statistics and outliers ggplot(mpg, aes(x = hwy)) + geom_boxplot() The histogram and density plot reveal that the distribution of highway mileage is bimodal and right skewed, while the boxplot reveals two potential outliers. ggplot2 provides more than 40 geoms but these don’t cover all possible plots one could make. The best place to get a comprehensive overview of all of the geoms ggplot2 offers is the reference page:. To learn more about any single geom, use the help (e.g., ?geom_smooth). 1.3.1 Dealing with Overplotting When you have many data points, they can overlap and hide each other. geom_jitter() adds a small amount of random noise to each point to spread them out: # Compare these two plots # Points overlap - hard to see how many there are ggplot(mpg, aes(x = class, y = hwy)) + geom_point() # Jittered points - easier to see individual observations ggplot(mpg, aes(x = class, y = hwy)) + geom_jitter(width = 0.2) The width argument controls how much horizontal jitter to add. Try different values to see what works best! geom_jitter is most often used with geom_boxplot which allows you to see all the points, not just the outliers. # Jittered points - easier to see individual observations ggplot(mpg, aes(x = class, y = hwy)) + geom_boxplot(outlier.shape = NA) + # Don&#39;t show outliers (we have jittered points) geom_jitter(aes(color = class), width = 0.2) # Notice if you change the order of `geom_point` with `geom_jitter` the boxplot argument dominates (layers STACK) ggplot(mpg, aes(x = class, y = hwy,color=class)) + geom_jitter(width = 0.2)+geom_boxplot(aes(color=class)) 1.3.1 Exercises What geom would you use to draw a line chart? A boxplot? A histogram? A scatterplot with points spread out to avoid overlap? (‘jitter plot’) +4pts or +5pts (bonus point for line charts using TWO geoms, how do they differ?) +4pts, +6pts with bonus Create a plot showing highway fuel economy (hwy) by car class (class) that includes both a boxplot and jittered individual points. Make the points semi-transparent. +3pts What does show.legend = FALSE do in the code below? What happens if you remove it? +2pts ggplot(mpg, aes(x = displ, y = hwy)) + geom_smooth(aes(color = drv), show.legend = FALSE) What does the se argument to geom_smooth() do? +2pts Will these two graphs look different? Why/why not? +2pts ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth() ggplot() + geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy)) 1.4 Facets Facets are a powerful way to split your plot into multiple subplots based on the values of one or more categorical variables. This is especially useful when you have too many categories to distinguish by color alone, or when you want to compare patterns across groups side-by-side. 1.4.1 Faceting by One Variable To facet your plot by a single variable, use facet_wrap(). The first argument of facet_wrap() is a formula (created with ~ followed by a variable name). The variable passed to facet_wrap() should be categorical. # Instead of trying to use 7 different colors for class... ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + facet_wrap(~ class, nrow = 2) This makes it much easier to see the relationship between engine size and fuel efficiency within each vehicle class. Notice how 2seaters behave differently from SUVs! 1.4.2 Faceting by Two Variables To facet your plot with the combination of two variables, use facet_grid(). The first argument of facet_grid() is also a formula, but now it’s a double sided formula: rows ~ cols. ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + facet_grid(drv ~ cyl) The first variable (drv) determines the faceting by row, the second (cyl) by column. This lets you see how both drive type and number of cylinders affect the relationship between engine size and highway mileage. 1.4.3 Adjusting Scales By default each of the facets share the same scale and range for x and y axes. This is useful when you want to compare data across facets, but it can be limiting when you want to visualize the relationship within each facet better. Setting the scales argument in a faceting function to \"free\" will allow for different axis scales across both rows and columns, \"free_x\" will allow for different scales across columns, and \"free_y\" will allow for different scales across rows. ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + facet_grid(drv ~ cyl,scales=&quot;free_y&quot;) Notice how the y-axis now adjusts for each row, making it easier to see the variation in highway mileage within each drive type. 1.4.1 Exercises What happens if you facet on a continuous variable? Try faceting the plot below on hwy. +2pts ggplot(mpg, aes(x = drv, y = cyl)) + geom_point() Run the following code and facet on drv vs cyl using facet_grid(). What do the empty cells mean? +2pts ggplot(mpg, aes(x = drv, y = cyl)) + geom_point() What plots does the following code make? What does . do? +2pts ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + facet_grid(drv ~ .) ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + facet_grid(. ~ cyl) What’s redundant about this plot? Why does cyl produce a gradient color scale instead of distinct colors? How could you improve the plot? +3pts ggplot(mpg, aes(x = displ, y = hwy, color = cyl)) + geom_point() + facet_grid(. ~ cyl) Take the first faceted plot in this section: ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + facet_wrap(~ class) What are the advantages to using faceting instead of the color aesthetic? What are the disadvantages? +4pts Read ?facet_wrap. What does nrow do? What does ncol do? Why doesn’t facet_grid() have nrow and ncol arguments? +2pts 1.5 Position adjustments Position adjustments control how geoms are arranged when they might overlap. This is particularly important for bar charts. You can color bar charts using either the color aesthetic (outline) or the fill aesthetic (inside): # Fill colors the inside of the bars ggplot(mpg, aes(x = drv, fill = drv)) + geom_bar() When you map fill to another variable, the bars are automatically stacked. Each colored rectangle represents a combination of the two variables: # Stacked bars (default) ggplot(mpg, aes(x = drv, fill = class)) + geom_bar() The stacking is controlled by the position argument. You can use different positions to change how the bars are displayed: 1.5.0.1 position = \"fill\" - Show proportions Makes each set of stacked bars the same height, making it easier to compare proportions across groups: # All bars go to 100% ggplot(mpg, aes(x = drv, fill = class)) + geom_bar(position = &quot;fill&quot;) 1.5.0.2 position = \"dodge\" - Side-by-side comparison Places bars directly beside one another, making it easier to compare individual counts: # Side-by-side bars ggplot(mpg, aes(x = drv, fill = class)) + geom_bar(position = &quot;dodge&quot;) Position adjustments summary: - position = \"stack\" (default for bars): Shows total counts with composition breakdown - position = \"fill\": Shows proportions (all bars reach 100%) - position = \"dodge\": Shows side-by-side for easy comparison - position = \"jitter\": Adds random noise to points to avoid overplotting (you learned this with geom_jitter() earlier!) To learn more about position adjustments, see ?position_dodge, ?position_fill, ?position_jitter, and ?position_stack. 1.6.1 Exercises What’s the difference between position = \"stack\" and position = \"fill\" for bar charts? When would you use each? +2pts Create a dodged bar chart showing the count of cars by class and drv. +2pts What’s the default position adjustment for geom_boxplot()? Create a visualization of the mpg dataset that demonstrates it. +2pts 1.6 Summary In this chapter you learned about the layered grammar of graphics starting with aesthetics and geometries to build a simple plot, facets for splitting the plot into subsets, and position adjustments for controlling how geoms are displayed when they might overlap. 1.6.1 Key concepts learned: Aesthetics: Map variables from your data to visual properties Inside aes() for variables: aes(color = class) Outside aes() for constants: color = \"blue\" Memory trick: Can you do mpg$class? YES → inside aes() Geoms: The geometric objects that represent your data geom_point(), geom_line(), geom_bar(), geom_boxplot(), geom_jitter(), etc. Can layer multiple geoms in one plot Layers stack, they don’t replace! Facets: Split your plot into subplots facet_wrap(~ variable) for one variable facet_grid(rows ~ cols) for two variables Use . as placeholder: facet_grid(. ~ cols) or facet_grid(rows ~ .) Position adjustments: Fine-tune positioning for overlapping geoms position = \"stack\" - default for bars (shows totals with composition) position = \"fill\" - proportional stacking (all bars reach 100%) position = \"dodge\" - side-by-side bars position = \"jitter\" - adds random noise to avoid overplotting 1.6.2 The grammar of graphics works like painting: Each + adds a new layer of paint on top. You can paint over something, but the old layer is still there underneath. Data layers stack, but display elements (themes, labels, scales) can be modified. Two very useful resources for getting an overview of the complete ggplot2 functionality are the ggplot2 cheatsheet or in your lessons folder and the ggplot2 package documentation. "],["communication.html", "Chapter 2 Communication: 2.1 Introduction 2.2 Labels 2.3 Annotations 2.4 Scales 2.5 Themes 2.6 Layout 2.7 Summary", " Chapter 2 Communication: Total points: 30 “The simple graph has brought more information to the data analyst’s mind than any other device.” — John Tukey Instructions: - This is the complete lessons version with all working examples - Run all the code as you go to see how everything works - Exercise questions are shown but without answer spaces - Use the STUDENT version to practice writing your own code 2.1 Introduction You’ve learned how to create exploratory plots to understand your data. Now we’ll focus on creating plots for communication - plots you’ll share with others who don’t know your data as well as you do. To help others quickly understand your plots, you need to make them as self-explanatory as possible. In this chapter, you’ll learn how to: Add informative labels (titles, axis labels, captions) Use annotations to highlight important features Customize scales (axes and legends) Apply themes to change the overall appearance Combine multiple plots for comparison These skills are essential for creating publication-quality figures for your research! 2.1.1 Prerequisites Load the necessary packages: library(tidyverse) # for ggplot2 and mpg library(ggrepel) # for smart label placement library(patchwork) # for combining plots library(scales) # for axis formatting 2.2 Labels The easiest place to start when turning an exploratory graphic into a publication-ready graphic is with good x and y-axes labels. You add labels with the labs() function: ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class)) + geom_smooth(se = FALSE) + labs( x = &quot;Engine displacement (L)&quot;, y = &quot;Highway fuel economy (mpg)&quot;, color = &quot;Car type&quot;, title = &quot;Fuel efficiency generally decreases with engine size&quot;, subtitle = &quot;Two seaters (sports cars) are an exception because of their light weight&quot;, caption = &quot;Data from fueleconomy.gov&quot; ) Important tips for plot titles: Good title: Summarizes the main finding → “Fuel efficiency generally decreases with engine size” Bad title: Just describes the plot → “A scatterplot of engine displacement vs. fuel economy” If you need to add more text, there are two other useful labels: subtitle adds additional detail in a smaller font beneath the title caption adds text at the bottom right of the plot, often used to describe the source of the data You can also use labs() to replace the axis and legend titles. It’s usually a good idea to replace short variable names with more detailed descriptions, and to include the units. Exercises 2.2.1 Add labels to make this plot publication-ready. Include a title describing an interesting pattern (not just “boxplot of…”), subtitle, caption, and improved axis/legend labels. +6pts Start with this plot: g1 &lt;- ggplot( data = mpg, mapping = aes(x = class, y = hwy, fill = class)) + geom_boxplot() g1 Recreate the following plot. Add appropriate labels for the axes and legend, AND add a meaningful title describing a pattern you see. Note that both color and shape vary by drive type. +6pts 2.3 Annotations In addition to labeling major components of your plot, it’s often useful to label individual observations or groups of observations. The first tool you have at your disposal is geom_text(). geom_text() is similar to geom_point(), but it has an additional aesthetic: label. This makes it possible to add textual labels to your plots. 2.3.1 Labeling specific points You might have a tibble that provides labels. In the following plot we pull out the cars with the highest engine size in each drive type and save their information as a new data frame called label_info. label_info &lt;- mpg |&gt; group_by(drv) |&gt; arrange(desc(displ)) |&gt; slice_head(n = 1) |&gt; mutate( drive_type = case_when( drv == &quot;f&quot; ~ &quot;front-wheel drive&quot;, drv == &quot;r&quot; ~ &quot;rear-wheel drive&quot;, drv == &quot;4&quot; ~ &quot;4-wheel drive&quot; ) ) |&gt; dplyr::select(displ, hwy, drv, drive_type) label_info displ hwy drv drive_type 6.5 17 4 4-wheel drive 5.3 25 f front-wheel drive 7.0 24 r rear-wheel drive Note: slice_head(n = 1) selects the first row of each group (after arranging by descending displacement), giving us the car with the largest engine in each drive type. Then, we use this new data frame to directly label the three groups. Using the fontface and size arguments we can customize the look of the text labels: ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + # geom_point(alpha = 0.3) + geom_smooth(se = FALSE) + geom_text( data = label_info, aes(x = displ, y = hwy, label = drive_type), fontface = &quot;bold&quot;, size = 5, hjust = &quot;right&quot;, vjust = &quot;bottom&quot; ) + theme(legend.position = &quot;none&quot;) Note: The use of hjust (horizontal justification) and vjust (vertical justification) to control the alignment of the label. We’ve seen this before, but it is slightly more complex here. alpha is fixed, yet we see different transparencies in the points. The annotated plot we made above is hard to read because the labels overlap with points. We can use the geom_label_repel() function from the ggrepel package to fix this. This useful package will automatically adjust labels so that they don’t overlap: ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + geom_point(alpha = 0.3) + geom_smooth(se = FALSE) + geom_label_repel( data = label_info, aes(x = displ, y = hwy, label = drive_type), fontface = &quot;bold&quot;, size = 5, nudge_y = 2 ) + theme(legend.position = &quot;none&quot;) You can also use the same idea to highlight certain points on a plot with geom_text_repel(). Note another handy technique used here: we added a second layer of large, hollow points to further highlight the labelled points. potential_outliers &lt;- mpg |&gt; filter(hwy &gt; 40 | (hwy &gt; 20 &amp; displ &gt; 5)) ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + geom_text_repel(data = potential_outliers, aes(label = model)) + geom_point(data = potential_outliers, color = &quot;red&quot;) + geom_point( data = potential_outliers, color = &quot;red&quot;, size = 3, shape = &quot;circle open&quot; ) 2.3.2 Using annotate() for single annotations Another handy function for adding annotations to plots is annotate(). While geom_text() is useful for labeling many points from your data, annotate() is useful for adding one or a few annotation elements to a plot. To demonstrate using annotate(), let’s create some text to add to our plot: trend_text &lt;- &quot;Larger engine sizes tend to have lower fuel economy.&quot; Then, we add two layers of annotation: one with a label geom and the other with a segment geom (an arrow): ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + annotate( geom = &quot;label&quot;, x = 3.5, y = 38, label = trend_text, hjust = &quot;left&quot;, color = &quot;red&quot; ) + annotate( geom = &quot;segment&quot;, x = 3, y = 35, xend = 5, yend = 25, color = &quot;red&quot;, arrow = arrow(type = &quot;closed&quot;) ) Other useful annotation geoms: Use geom_hline() and geom_vline() to add reference lines Use geom_rect() to draw a rectangle around points of interest Use geom_segment() with the arrow argument to draw attention to a point Annotation is a powerful tool for communicating main takeaways and interesting features of your visualizations! Exercises 2.3.1 Use annotate() to add a point geom in the middle of the following plot without having to create a tibble. Customize the shape, size, or color of the point. +2pts ggplot(mpg, aes(displ, hwy)) + geom_point() How do labels with geom_text() interact with faceting? How can you add a label to a single facet? How can you put a different label in each facet? +4pts What arguments to geom_label() control the appearance of the background box? +2pts 2.4 Scales The third way you can make your plot better for communication is to adjust the scales. Scales control how the aesthetic mappings manifest visually. 2.4.1 Default scales Normally, ggplot2 automatically adds scales for you. For example, when you type: ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class)) ggplot2 automatically adds default scales behind the scenes: ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class)) + scale_x_continuous() + scale_y_continuous() + scale_color_discrete() Note: The naming scheme for scales: scale_ followed by the name of the aesthetic, then _, then the name of the scale. The default scales are named according to the type of variable they align with: continuous, discrete, datetime, or date. There are lots of non-default scales which you’ll learn about below. The default scales have been carefully chosen to do a good job for a wide range of inputs. Nevertheless, you might want to override the defaults for two reasons: You might want to tweak some of the parameters of the default scale (e.g., change the breaks on the axes, or the key labels on the legend) You might want to replace the scale altogether and use a completely different algorithm (e.g., use a log scale) 2.4.2 Axis ticks and legend keys Collectively, axes and legends are called guides. Axes are used for x and y aesthetics; legends are used for everything else. There are two primary arguments that affect the appearance of the ticks on the axes and the keys on the legend: breaks and labels. Breaks controls the position of the ticks, or the values associated with the keys. Labels controls the text label associated with each tick/key. The most common use of breaks is to override the default choice: ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + scale_y_continuous(breaks = seq(15, 40, by = 5)) You can use labels in the same way (a character vector the same length as breaks), but you can also set it to NULL to suppress the labels altogether. # Remove axis labels ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + scale_x_continuous(labels = NULL) + scale_y_continuous(labels = NULL) You can also use breaks and labels to control the appearance of legends. For example, here we remove the legend labels for the color aesthetic: ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + scale_color_discrete(labels = NULL) 2.4.3 Legend layout You will most often use breaks and labels to tweak the axes. While they both also work for legends, there are a few other techniques you are more likely to use. To control the overall position of the legend, you need to use a theme() setting. We’ll come back to themes at the end of the chapter, but in brief, they control the non-data parts of the plot. The theme setting legend.position controls where the legend is drawn: base &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class)) base + theme(legend.position = &quot;right&quot;) # the default base + theme(legend.position = &quot;left&quot;) base + theme(legend.position = &quot;top&quot;) base + theme(legend.position = &quot;bottom&quot;) base + theme(legend.position = &quot;none&quot;) # remove legend 2.4.4 Replacing a scale Instead of just tweaking the details a little, you can instead replace the scale altogether. There are two types of scales you’re mostly likely to want to switch out: continuous position scales and color scales. It’s very useful to plot transformations of your data. For example, it’s easier to see the precise relationship between carat and price if we log transform them: # Left: original scale ggplot(diamonds, aes(x = carat, y = price)) + geom_bin2d() # Right: log-transformed scale ggplot(diamonds, aes(x = carat, y = price)) + geom_bin2d() + scale_x_log10() + scale_y_log10() Another scale that is frequently customized is color. The default categorical scale picks colors that are evenly spaced around the color wheel. A popular alternative is the ColorBrewer scales which have been hand-tuned to work better for people with common types of color blindness. The two plots below don’t look that different, but there is enough difference in the shades of red and green that they can still be distinguished even by people with red-green color blindness. # Default colors ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = drv)) # ColorBrewer colors ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = drv)) + scale_color_brewer(palette = &quot;Set1&quot;) Don’t forget simpler techniques. If there are just a few colors, you can add a redundant shape mapping. This will also help ensure your plot is interpretable in black and white. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = drv, shape = drv)) + scale_color_brewer(palette = &quot;Set1&quot;) The ColorBrewer scales are documented at https://colorbrewer2.org/ and made available in R via the RColorBrewer package, by Erich Neuwirth. You can see all the available palettes with RColorBrewer::display.brewer.all(). When you have a predefined mapping between values and colors, use scale_color_manual(). For example, if we map presidential party to color (see ?presidential), we want to use the standard mapping of red for Republicans and blue for Democrats. One approach is to use scale_color_manual(): presidential |&gt; # to assign an ID to each president mutate(id = 33 + row_number()) |&gt; ggplot(aes(x = start, y = id, color = party)) + geom_point() + geom_segment(aes(xend = end, yend = id)) + scale_color_manual(values = c(Republican = &quot;#E81B23&quot;, Democratic = &quot;#00AEF3&quot;)) For continuous color, you can use the built-in scale_color_gradient() or scale_fill_gradient() that you have seen before. If you have a diverging scale, you can use scale_color_gradient2(). That allows you to give a different color for the midpoint (usually 0). Exercises 2.4.1 Why doesn’t the following code override the default scale? Fix the plot so that it colors the points with a gradient. +2pts df &lt;- tibble(x = rnorm(10000), y = rnorm(10000)) ggplot(df) + geom_point(aes(x = x, y = y, fill = x)) + scale_fill_gradient(low = &quot;yellow&quot;, high = &quot;red&quot;) What is the first argument to every scale? How does it compare to labs()? +2pts 2.5 Themes You can customize the overall appearance of your plot with built-in themes: ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class)) + geom_smooth(se = FALSE) + theme_classic() ggplot2 includes eight built-in themes, with theme_gray() as the default: theme_gray() - The default (gray background, white gridlines) theme_bw() - White background with gridlines theme_classic() - No gridlines (classic look for publications) theme_minimal() - Minimal theme theme_light() - Light background theme_dark() - Dark background theme_linedraw() - Black lines theme_void() - Empty theme Figure 2.1: The eight themes built-in to ggplot2. For publication figures, theme_bw(), theme_classic(), and theme_minimal() are popular choices. You can also customize individual theme elements using theme(). For example, to move the legend position: ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + theme_bw() + theme(legend.position = &quot;bottom&quot;) Common theme customizations include legend.position, plot.title, and axis.text. For a complete list, see ?theme. Exercises 2.5.1 Apply a different theme to the following plot. Try theme_bw(), theme_classic(), or theme_minimal(). Which do you think looks best for a publication? +2pts ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + labs( title = &quot;Larger engine sizes tend to have lower fuel economy&quot;, caption = &quot;Source: https://fueleconomy.gov.&quot; ) 2.6 Layout So far we talked about how to create and modify a single plot. What if you have multiple plots you want to lay out in a certain way? The patchwork package allows you to combine separate plots into the same graphic. To place two plots next to each other, you can simply add them to each other. Note that you first need to create the plots and save them as objects: p1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + labs(title = &quot;Plot 1&quot;) p2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + geom_boxplot() + labs(title = &quot;Plot 2&quot;) # Place side-by-side with + p1 + p2 You can also stack plots vertically using /: # Stack vertically with / p1 / p2 You can create more complex layouts using both + and /. Use parentheses to control the order of operations: p3 &lt;- ggplot(mpg, aes(x = cty, y = hwy)) + geom_point() + labs(title = &quot;Plot 3&quot;) # p1 and p3 side-by-side, then p2 below (p1 + p3) / p2 Additionally, patchwork allows you to add a common title, subtitle, and caption to your combined plots using plot_annotation(): (p1 + p2) / p3 + plot_annotation( title = &quot;Fuel economy analysis&quot;, subtitle = &quot;Exploring the mpg dataset&quot;, caption = &quot;Data from fueleconomy.gov&quot; ) If you’d like to learn more about patchwork, see the package website: https://patchwork.data-imaginist.com. Exercises 2.6.1 What happens if you omit the parentheses in the following plot layout? Try it. Can you explain why this happens? +2pts p1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + labs(title = &quot;Plot 1&quot;) p2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + geom_boxplot() + labs(title = &quot;Plot 2&quot;) p3 &lt;- ggplot(mpg, aes(x = cty, y = hwy)) + geom_point() + labs(title = &quot;Plot 3&quot;) (p1 + p3) / p2 Using the three plots from the previous exercise, recreate the following patchwork with p1 on top and p2 and p3 side-by-side on the bottom: +2pts 2.7 Summary In this chapter you’ve learned about: Labels: Adding informative titles, subtitles, captions, and axis labels with labs() Annotations: Using geom_text(), geom_label_repel(), and annotate() to highlight specific features Scales: Customizing axes and legends with scale_*() functions Themes: Changing the overall appearance with built-in themes and theme() customization Layout: Combining multiple plots with the patchwork package using + and / These skills are essential for creating publication-quality figures for your research! While you’ve learned how to make many different types of plots and customize them, we’ve barely scratched the surface of what you can do with ggplot2. If you want to get a comprehensive understanding, we recommend: ggplot2: Elegant Graphics for Data Analysis by Hadley Wickham R Graphics Cookbook by Winston Chang Fundamentals of Data Visualization by Claus Wilke "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
